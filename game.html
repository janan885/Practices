<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Interactive Cursor Snack</title>
<style>
  :root{
    --bg:#070507;
    --glowA: rgba(120,255,170,0.95);
    --glowB: rgba(80,200,255,0.92);
    --accent: rgba(255,220,120,0.98);
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#050507 0%, #071017 100%);font-family:Inter, system-ui, Arial;color:#eaf7ff;overflow:hidden}
  canvas{display:block;width:100vw;height:100vh;cursor:none}
  .hint{
    position:fixed;left:12px;top:12px;padding:8px 10px;border-radius:8px;
    background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.03);
    font-size:13px;color:#dfffe8;backdrop-filter:blur(6px)
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hint">Move mouse / touch â€” snack will follow the cursor. Click to nibble (bite).</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', {alpha:true});
  let DPR = window.devicePixelRatio || 1;

  function resize(){
    DPR = window.devicePixelRatio || 1;
    canvas.width = Math.floor(innerWidth * DPR);
    canvas.height = Math.floor(innerHeight * DPR);
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  addEventListener('resize', resize);
  resize();

  // Configuration:
  const SEGMENTS = 26;         // body segments (snack pieces)
  const SEG_SPACING = 12;      // distance spacing
  const HEAD_SIZE = 26;        // main snack "head" radius
  const TAIL_SIZE = 6;
  const FOLLOW_SPEED = 0.18;   // head follow smoothing
  const GLOW = 1.0;

  // Segment state
  const segments = [];
  for(let i=0;i<SEGMENTS;i++){
    segments.push({
      x: innerWidth/2,
      y: innerHeight/2,
      angle: 0,
      size: HEAD_SIZE - (i/SEGMENTS)*(HEAD_SIZE-TAIL_SIZE),
      wob: Math.random()*1000
    });
  }

  // cursor target
  const target = {x: innerWidth/2, y: innerHeight/2, down:false};

  // input
  function setTarget(x,y){ target.x = x; target.y = y; }
  addEventListener('mousemove', e => setTarget(e.clientX, e.clientY), {passive:true});
  addEventListener('touchmove', e => { e.preventDefault(); const t=e.touches[0]; if(t) setTarget(t.clientX, t.clientY); }, {passive:false});
  addEventListener('mousedown', ()=> target.down=true);
  addEventListener('mouseup', ()=> target.down=false);
  addEventListener('touchstart', ()=> target.down=true, {passive:true});
  addEventListener('touchend', ()=> target.down=false, {passive:true});
  addEventListener('mouseleave', ()=> target.down=false);

  // particles for sprinkles and bite
  const particles = [];

  function spawnParticles(x,y,color,amount=12){
    for(let i=0;i<amount;i++){
      particles.push({
        x, y,
        vx: (Math.random()-0.5)*6,
        vy: (Math.random()-0.9)*-6 - Math.random()*3,
        life: 1 + Math.random()*0.6,
        size: 1 + Math.random()*3,
        color
      });
    }
  }

  // utils
  function lerp(a,b,t){ return a + (b-a)*t; }
  function dist(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return Math.sqrt(dx*dx + dy*dy); }

  // main animation
  let last = performance.now();
  function frame(now){
    const dt = Math.min(40, now - last)/1000;
    last = now;

    // clear with slight translucent fill for trailing glow (creates blur trails)
    ctx.clearRect(0,0,innerWidth, innerHeight);
    ctx.fillStyle = "rgba(5,6,8,0.12)";
    ctx.fillRect(0,0,innerWidth,innerHeight);

    // update head follows target
    const head = segments[0];
    const dx = target.x - head.x;
    const dy = target.y - head.y;
    head.x += dx * FOLLOW_SPEED * (1 + dt*2);
    head.y += dy * FOLLOW_SPEED * (1 + dt*2);
    head.angle = Math.atan2(dy, dx);

    // scale head if mouse down (nibble effect)
    head.size = lerp(head.size, HEAD_SIZE * (target.down ? 0.8 : 1.0), 0.18);

    // update body segments
    for(let i=1;i<segments.length;i++){
      const prev = segments[i-1];
      const seg = segments[i];
      const ox = prev.x - seg.x;
      const oy = prev.y - seg.y;
      const d = Math.sqrt(ox*ox + oy*oy) || 0.0001;
      // move segment toward previous while keeping spacing
      const desired = SEG_SPACING * (1 + i*0.02);
      const pull = (d - desired) / d;
      seg.x += ox * pull * 0.6;
      seg.y += oy * pull * 0.6;
      // subtle wobble for organic feel
      seg.wob += dt * 5 + i*0.01;
      const wobble = Math.sin(seg.wob*1.7 + i*0.6) * (1.2 + i*0.02);
      seg.x += Math.cos(seg.wob) * wobble * 0.02;
      seg.y += Math.sin(seg.wob) * wobble * 0.02;
      seg.angle = Math.atan2(prev.y - seg.y, prev.x - seg.x);
      seg.size = lerp(seg.size, HEAD_SIZE - (i/SEGMENTS)*(HEAD_SIZE-TAIL_SIZE), 0.12);
    }

    // draw glow ribbon (several strokes for neon)
    ctx.save();
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';

    // outer glows
    for(let pass=0; pass<3; pass++){
      ctx.beginPath();
      for(let i=0;i<segments.length;i++){
        const s = segments[i];
        if(i===0) ctx.moveTo(s.x, s.y);
        else ctx.lineTo(s.x, s.y);
      }
      const width = 36 - pass*10;
      const alpha = 0.08 + pass*0.06;
      ctx.strokeStyle = `rgba(60,255,180,${alpha*GLOW})`;
      ctx.lineWidth = width;
      ctx.shadowBlur = 30 - pass*8;
      ctx.shadowColor = 'rgba(70,230,190,0.85)';
      ctx.stroke();
    }

    // inner core ribbon with color shift
    for(let i=0;i<segments.length-1;i++){
      const a = segments[i];
      const b = segments[i+1];
      const g = ctx.createLinearGradient(a.x,a.y,b.x,b.y);
      const t = i/segments.length;
      // color shift: green -> cyan -> warm
      const r1 = Math.floor(30 + t*200);
      const g1 = Math.floor(200 - t*40);
      const b1 = Math.floor(180 - t*100);
      const r2 = Math.floor(180 - t*80);
      const g2 = Math.floor(230 - t*120);
      const b2 = Math.floor(200 - t*70);
      g.addColorStop(0, `rgba(${r1},${g1},${b1},${1 - t*0.5})`);
      g.addColorStop(1, `rgba(${r2},${g2},${b2},${0.6 - t*0.3})`);
      ctx.strokeStyle = g;
      ctx.lineWidth = Math.max(2, a.size*0.9);
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.shadowBlur = 18;
      ctx.shadowColor = 'rgba(140,255,200,0.7)';
      ctx.stroke();
    }

    // draw snack segments (circles with glaze + sprinkles)
    for(let i=0;i<segments.length;i++){
      const s = segments[i];
      // glow halo
      ctx.beginPath();
      ctx.fillStyle = `rgba(90,255,180,${0.02 + (1 - i/segments.length)*0.12})`;
      ctx.shadowBlur = 12 * (1 + (1 - i/segments.length)*0.6);
      ctx.shadowColor = `rgba(80,220,170,${0.25 + (1 - i/segments.length)*0.6})`;
      ctx.arc(s.x, s.y, s.size*1.4, 0, Math.PI*2);
      ctx.fill();

      // main cookie/glazed snack body (circular-ish)
      ctx.beginPath();
      // draw an ellipse rotated to segment angle for organic look
      ctx.save();
      ctx.translate(s.x, s.y);
      ctx.rotate(s.angle);
      // base color gradient for the snack
      const grad = ctx.createLinearGradient(-s.size, -s.size, s.size, s.size);
      grad.addColorStop(0, `rgba(255,235,180,${0.98 - i/segments.length*0.15})`);
      grad.addColorStop(1, `rgba(255,200,120,${0.88 - i/segments.length*0.2})`);
      ctx.fillStyle = grad;
      ctx.shadowBlur = 6;
      ctx.shadowColor = 'rgba(0,0,0,0.15)';
      ctx.beginPath();
      // draw irregular rounded shape using bezier approximations
      const w = s.size;
      const h = s.size * (0.82 + Math.sin(s.wob*0.5)*0.06);
      ctx.ellipse(0,0, w, h, 0, 0, Math.PI*2);
      ctx.fill();

      // glossy glaze highlight
      ctx.beginPath();
      ctx.fillStyle = `rgba(255,255,255,${0.16 + (1 - i/segments.length)*0.12})`;
      ctx.ellipse(-w*0.25, -h*0.45, w*0.5, h*0.35, -0.35, 0, Math.PI*2);
      ctx.fill();

      // small chocolate chips / sprinkles on head-most and near segments
      if(i <= 4 || i%6===0){
        const chips = 3;
        for(let c=0;c<chips;c++){
          const ang = (c/chips) * Math.PI*2 + s.wob*0.2;
          const cx = Math.cos(ang) * (w*0.35) + (Math.random()-0.5)*2;
          const cy = Math.sin(ang) * (h*0.25) + (Math.random()-0.5)*2;
          ctx.beginPath();
          ctx.fillStyle = c%2===0 ? 'rgba(90,50,30,0.96)' : 'rgba(60,30,20,0.9)';
          ctx.arc(cx, cy, Math.max(1.2, w*0.09), 0, Math.PI*2);
          ctx.fill();
        }
      }

      ctx.restore();
    }

    // draw head details (larger, eye-like shine & bite if clicked)
    const H = segments[0];
    // eye-ish bright core
    ctx.beginPath();
    ctx.fillStyle = 'rgba(250,255,230,0.98)';
    ctx.shadowBlur = 18;
    ctx.shadowColor = 'rgba(255,245,200,0.9)';
    ctx.arc(H.x + Math.cos(H.angle)* (H.size*0.35), H.y + Math.sin(H.angle)*(H.size*0.35), Math.max(3, H.size*0.26), 0, Math.PI*2);
    ctx.fill();

    // if clicked (bite), spawn particles and show small notch - implement nibble visual by temporarily shading segments near head
    if(target.down){
      // darker notch overlay on a few near-head segments to simulate a bite
      ctx.save();
      ctx.globalCompositeOperation = 'multiply';
      ctx.fillStyle = 'rgba(10,10,10,0.06)';
      for(let i=0;i<4;i++){
        const s = segments[i];
        ctx.beginPath();
        ctx.ellipse(s.x - Math.cos(s.angle)*s.size*0.35, s.y - Math.sin(s.angle)*s.size*0.35, s.size*0.7, s.size*0.5, s.angle - 0.6, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }

    // update and draw particles
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.vy += 14 * dt;
      p.x += p.vx;
      p.y += p.vy;
      p.life -= dt * 1.4;
      if(p.life <= 0){ particles.splice(i,1); continue; }
      ctx.save();
      ctx.globalAlpha = Math.max(0, Math.min(1, p.life));
      ctx.beginPath();
      ctx.fillStyle = p.color;
      ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // tiny trailing dots along spine for extra glow
    for(let i=2;i<segments.length-4;i+=3){
      const s = segments[i];
      ctx.beginPath();
      ctx.fillStyle = `rgba(255,255,220,${0.06 + (1 - i/segments.length)*0.26})`;
      ctx.arc(s.x, s.y, Math.max(0.8, s.size*0.12), 0, Math.PI*2);
      ctx.fill();
    }

    // request next frame
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // spawn nibble particles when mouse down toggles true (only once per down)
  let lastDown = false;
  function checkBite(){
    if(target.down && !lastDown){
      // spawn at head location
      const h = segments[0];
      const colors = ['#ff7b7b','#ffd48a','#77f0b0','#7fd3ff','#f09ec9'];
      for(let i=0;i<22;i++){
        spawnParticles(h.x + (Math.random()-0.5)*10, h.y + (Math.random()-0.5)*10, colors[(i%colors.length)]);
      }
      // also small recoil: push head slightly back
      h.x -= Math.cos(h.angle) * 6;
      h.y -= Math.sin(h.angle) * 6;
    }
    lastDown = target.down;
    requestAnimationFrame(checkBite);
  }
  requestAnimationFrame(checkBite);

  // for touch, spawn gentle particle on tap
  addEventListener('click', e => {
    const rect = canvas.getBoundingClientRect();
    spawnParticles(target.x, target.y, '#ffd28a', 14);
  }, {passive:true});

  // idle motion when no movement (makes snack 'float')
  let idle = 0;
  addEventListener('mousemove', ()=> idle = 0);
  addEventListener('touchmove', ()=> idle = 0);
  setInterval(()=> {
    idle++;
    if(idle > 160){
      // drift target in slow circle
      const t = performance.now()/2000;
      setTarget(innerWidth/2 + Math.cos(t)*120, innerHeight/2 + Math.sin(t*1.3)*80);
    }
  }, 1000);

  // initialize center
  setTarget(innerWidth/2, innerHeight/2);

})();
</script>
</body>
</html>